//! Build script for ASN.1 schema compilation and code generation.

use anyhow::{Context, Result};
use heck::ToPascalCase;
use rustyfix_dictionary::Dictionary;
use std::collections::{BTreeMap, HashSet};
use std::env;
use std::fs;
use std::path::{Path, PathBuf};

/// Sanitizes a string to be a valid Rust identifier by replacing invalid characters.
/// For message types, preserves alphanumeric characters and replaces others with underscores.
/// Does not add prefix for numeric message types since they'll be used after an underscore.
fn sanitize_identifier(input: &str) -> String {
    let mut result = String::new();

    for ch in input.chars() {
        if ch.is_ascii_alphanumeric() {
            result.push(ch);
        } else {
            // Replace invalid characters (like /, +, -, etc.) with underscore
            result.push('_');
        }
    }

    // Ensure result is not empty
    if result.is_empty() {
        result = "_".to_string();
    }

    result
}

fn main() -> Result<()> {
    // Set up rerun conditions
    println!("cargo:rerun-if-changed=build.rs");
    println!("cargo:rerun-if-changed=schemas/");

    // Check available features dynamically
    let enabled_features = get_enabled_fix_features();
    println!("cargo:warning=Detected FIX features: {enabled_features:?}");

    // Generate ASN.1 definitions from FIX dictionaries
    generate_fix_asn1_definitions(&enabled_features)
        .context("Failed to generate FIX ASN.1 definitions")?;

    // Generate additional ASN.1 schema files if they exist
    generate_custom_asn1_schemas().context("Failed to generate custom ASN.1 schemas")?;

    Ok(())
}

/// Gets the list of enabled FIX features dynamically.
fn get_enabled_fix_features() -> Vec<String> {
    let mut features = Vec::new();

    // Always include FIX 4.4 as it's the primary version (no feature flag required)
    features.push("fix44".to_string());

    // Check for optional features dynamically - only include those that exist in build dependencies
    let available_features = ["fix40", "fix50"]; // Based on build-dependencies in Cargo.toml

    for feature in available_features {
        let env_var = format!("CARGO_FEATURE_{}", feature.to_uppercase());
        if env::var(&env_var).is_ok() {
            features.push(feature.to_string());
        }
    }

    features
}

/// Generates ASN.1 type definitions from FIX dictionaries.
fn generate_fix_asn1_definitions(enabled_features: &[String]) -> Result<()> {
    let out_dir = env::var("OUT_DIR").context("Failed to get OUT_DIR environment variable")?;
    let out_path = Path::new(&out_dir);

    for feature in enabled_features {
        let (dict_result, filename) = match feature.as_str() {
            "fix40" => (Dictionary::fix40(), "fix40_asn1.rs"),
            "fix44" => (Dictionary::fix44(), "fix44_asn1.rs"),
            "fix50" => (Dictionary::fix50(), "fix50_asn1.rs"),
            _ => {
                println!(
                    "cargo:warning=Skipping unavailable FIX feature: {feature} (not enabled in build dependencies)"
                );
                continue;
            }
        };

        let dictionary = dict_result
            .with_context(|| format!("Failed to parse {} dictionary", feature.to_uppercase()))?;

        println!(
            "cargo:warning=Generating ASN.1 definitions for {}",
            feature.to_uppercase()
        );
        generate_fix_dictionary_asn1(&dictionary, filename, out_path)
            .with_context(|| format!("Failed to generate ASN.1 definitions for {feature}"))?;
    }

    Ok(())
}

/// Generates ASN.1 definitions for a specific FIX dictionary.
fn generate_fix_dictionary_asn1(
    dictionary: &Dictionary,
    filename: &str,
    out_path: &Path,
) -> Result<()> {
    let mut output = String::new();

    // File header
    output.push_str(&format!(
        r#"// Generated ASN.1 definitions for FIX {}.
// This file is automatically generated by the build script.
// DO NOT EDIT MANUALLY - ALL CHANGES WILL BE OVERWRITTEN.
// Generated on: {}

use rasn::{{AsnType, Decode, Encode}};
use crate::types::{{Field, ToFixFieldValue}};

"#,
        dictionary.version(),
        chrono::Utc::now().format("%Y-%m-%d %H:%M:%S UTC")
    ));

    // Generate message type enums
    output.push_str(&generate_message_type_enum(dictionary)?);
    output.push_str("\n\n");

    // Generate field tag enums
    output.push_str(&generate_field_tag_enum(dictionary)?);
    output.push_str("\n\n");

    // Generate message structures
    output.push_str(&generate_message_structures(dictionary)?);
    output.push_str("\n\n");

    // Generate field value enums
    output.push_str(&generate_field_value_enums(dictionary)?);

    // Write to output file
    let file_path = out_path.join(filename);
    fs::write(file_path, output)
        .with_context(|| format!("Failed to write ASN.1 definitions to {filename}"))?;

    Ok(())
}

/// Generates ASN.1 enum for FIX message types.
fn generate_message_type_enum(dictionary: &Dictionary) -> Result<String> {
    let mut output = String::new();

    output.push_str(
        r#"/// ASN.1 enumeration of FIX message types.
#[derive(AsnType, Debug, Clone, Copy, PartialEq, Eq, Hash, Encode, Decode)]
#[rasn(crate_root = "rasn")]
#[rasn(enumerated)]
pub enum FixMessageType {
"#,
    );

    // Collect all message types
    let mut message_types: BTreeMap<String, String> = BTreeMap::new();
    let mut used_names = HashSet::new();

    for message in dictionary.messages() {
        let msg_type = message.msg_type();
        let name = message.name();
        let sanitized_msg_type = sanitize_identifier(msg_type);
        // For clean alphanumeric message types, concatenate without underscore for better Rust naming
        let mut enum_name = if sanitized_msg_type
            .chars()
            .all(|c| c.is_ascii_alphanumeric())
        {
            format!("{}{}", name.to_pascal_case(), sanitized_msg_type)
        } else {
            // Use underscore for complex sanitized types (those with replaced characters)
            format!("{}_{}", name.to_pascal_case(), sanitized_msg_type)
        };

        // Handle name collisions
        let mut counter = 1;
        while used_names.contains(&enum_name) {
            if sanitized_msg_type
                .chars()
                .all(|c| c.is_ascii_alphanumeric())
            {
                enum_name = format!("{}{}{}", name.to_pascal_case(), sanitized_msg_type, counter);
            } else {
                enum_name = format!(
                    "{}_{}{}",
                    name.to_pascal_case(),
                    sanitized_msg_type,
                    counter
                );
            }
            counter += 1;
        }
        used_names.insert(enum_name.clone());

        message_types.insert(msg_type.to_string(), enum_name);
    }

    // Generate enum variants
    for (discriminant, (msg_type, enum_name)) in message_types.iter().enumerate() {
        output.push_str(&format!(
            "    /// Message type '{msg_type}'\n    {enum_name} = {discriminant},\n"
        ));
    }

    output.push_str("}\n\n");

    // Generate conversion implementations
    output.push_str(&format!(
        r#"impl FixMessageType {{
    /// Gets the FIX message type string.
    pub fn as_str(&self) -> &'static str {{
        match self {{
{}        }}
    }}
    
    /// Creates from FIX message type string.
    pub fn from_str(s: &str) -> Option<Self> {{
        match s {{
{}            _ => None,
        }}
    }}
}}

impl ToFixFieldValue for FixMessageType {{
    fn to_fix_field_value(&self) -> crate::types::FixFieldValue {{
        crate::types::FixFieldValue::String(self.as_str().to_string())
    }}
}}
"#,
        message_types
            .iter()
            .map(|(msg_type, enum_name)| format!(
                "            Self::{enum_name} => \"{msg_type}\",\n"
            ))
            .collect::<String>(),
        message_types
            .iter()
            .map(|(msg_type, enum_name)| format!(
                "            \"{msg_type}\" => Some(Self::{enum_name}),\n"
            ))
            .collect::<String>()
    ));

    Ok(output)
}

/// Generates ASN.1 enum for FIX field tags.
fn generate_field_tag_enum(dictionary: &Dictionary) -> Result<String> {
    let mut output = String::new();

    output.push_str(
        r#"/// ASN.1 enumeration of FIX field tags.
#[derive(AsnType, Debug, Clone, Copy, PartialEq, Eq, Hash, Encode, Decode)]
#[rasn(crate_root = "rasn")]
#[rasn(enumerated)]
pub enum FixFieldTag {
"#,
    );

    // Collect all field tags
    let mut field_tags: BTreeMap<u32, String> = BTreeMap::new();

    for field in dictionary.fields() {
        let tag = field.tag();
        let name = field.name().to_pascal_case();
        field_tags.insert(tag.get(), name);
    }

    // Generate enum variants
    for (tag, name) in &field_tags {
        output.push_str(&format!(
            "    /// Field tag {tag} ({name})\n    {name} = {tag},\n"
        ));
    }

    output.push_str("}\n\n");

    // Generate conversion implementations
    output.push_str(&format!(
        r#"impl FixFieldTag {{
    /// Gets the field tag number.
    pub fn as_u32(&self) -> u32 {{
        *self as u32
    }}
    
    /// Creates from field tag number.
    pub fn from_u32(tag: u32) -> Option<Self> {{
        match tag {{
{}            _ => None,
        }}
    }}
}}

impl From<FixFieldTag> for u32 {{
    fn from(tag: FixFieldTag) -> Self {{
        tag.as_u32()
    }}
}}

impl ToFixFieldValue for FixFieldTag {{
    fn to_fix_field_value(&self) -> crate::types::FixFieldValue {{
        crate::types::FixFieldValue::UnsignedInteger(self.as_u32() as u64)
    }}
}}
"#,
        field_tags
            .iter()
            .map(|(tag, name)| format!("            {tag} => Some(Self::{name}),\n"))
            .collect::<String>()
    ));

    Ok(output)
}

/// Generates ASN.1 message structures for different FIX message types.
fn generate_message_structures(_dictionary: &Dictionary) -> Result<String> {
    let mut output = String::new();

    // Generate a generic ASN.1 message container
    output.push_str(
        r#"/// Generic ASN.1 FIX message structure.
#[derive(AsnType, Debug, Clone, PartialEq, Encode, Decode)]
#[rasn(crate_root = "rasn")]
pub struct Asn1FixMessage {
    /// Message type
    #[rasn(tag(0))]
    pub msg_type: FixMessageType,
    
    /// Sender company ID
    #[rasn(tag(1))]
    pub sender_comp_id: String,
    
    /// Target company ID  
    #[rasn(tag(2))]
    pub target_comp_id: String,
    
    /// Message sequence number
    #[rasn(tag(3))]
    pub msg_seq_num: u64,
    
    /// Sending time (optional)
    #[rasn(tag(4))]
    pub sending_time: Option<String>,
    
    /// Message fields
    #[rasn(tag(5))]
    pub fields: Vec<Asn1Field>,
}

/// ASN.1 representation of a FIX field.
#[derive(AsnType, Debug, Clone, PartialEq, Encode, Decode)]
#[rasn(crate_root = "rasn")]
pub struct Asn1Field {
    /// Field tag
    #[rasn(tag(0))]
    pub tag: FixFieldTag,
    
    /// Field value as string
    #[rasn(tag(1))]
    pub value: String,
}

"#,
    );

    // Generate conversion methods
    output.push_str(
        r#"impl Asn1FixMessage {
    /// Converts from the simple FixMessage representation.
    pub fn from_fix_message(msg: &crate::types::FixMessage) -> Option<Self> {
        let msg_type = FixMessageType::from_str(&msg.msg_type)?;
        
        // Extract sending time from fields if present (tag 52)
        let sending_time = msg.fields
            .iter()
            .find(|field| field.tag == 52)
            .map(|field| field.value.to_string());
        
        let fields = msg.fields
            .iter()
            .filter_map(|field| {
                let tag = FixFieldTag::from_u32(field.tag as u32)?;
                Some(Asn1Field {
                    tag,
                    value: field.value.to_string(),
                })
            })
            .collect();
        
        Some(Self {
            msg_type,
            sender_comp_id: msg.sender_comp_id.clone(),
            target_comp_id: msg.target_comp_id.clone(),
            msg_seq_num: msg.msg_seq_num,
            sending_time,
            fields,
        })
    }
    
    /// Converts to the simple FixMessage representation.
    pub fn to_fix_message(&self) -> crate::types::FixMessage {
        let fields = self.fields
            .iter()
            .map(|field| Field {
                tag: field.tag.as_u32(),
                value: crate::types::FixFieldValue::String(field.value.clone()),
            })
            .collect();
        
        crate::types::FixMessage {
            msg_type: self.msg_type.as_str().to_string(),
            sender_comp_id: self.sender_comp_id.clone(),
            target_comp_id: self.target_comp_id.clone(),
            msg_seq_num: self.msg_seq_num,
            fields,
        }
    }
}

"#,
    );

    Ok(output)
}

/// Generates ASN.1 enums for FIX field values that have restricted sets.
fn generate_field_value_enums(dictionary: &Dictionary) -> Result<String> {
    let mut output = String::new();

    output.push_str("// Field value enumerations\n\n");

    for field in dictionary.fields() {
        if let Some(enums) = field.enums() {
            let enums_vec: Vec<_> = enums.collect();
            let field_name = field.name().to_pascal_case();
            let enum_name = format!("{field_name}Value");

            output.push_str(&format!(
                r#"/// Allowed values for field {} (tag {}).
#[derive(AsnType, Debug, Clone, Copy, PartialEq, Eq, Hash, Encode, Decode)]
#[rasn(crate_root = "rasn")]
#[rasn(enumerated)]
pub enum {} {{
"#,
                field.name(),
                field.tag(),
                enum_name
            ));

            // Generate enum variants
            for (discriminant, enum_value) in enums_vec.iter().enumerate() {
                let mut variant_name = if enum_value.description().is_empty() {
                    enum_value.value()
                } else {
                    enum_value.description()
                }
                .to_pascal_case();

                // Handle identifiers that start with numbers
                if variant_name
                    .chars()
                    .next()
                    .is_some_and(|c| c.is_ascii_digit())
                {
                    variant_name = format!("V{variant_name}");
                }

                // Handle invalid characters
                variant_name = variant_name.replace(['/', ':', '-', ' ', '(', ')', '.'], "_");

                output.push_str(&format!(
                    "    /// {}\n    {} = {},\n",
                    if enum_value.description().is_empty() {
                        ""
                    } else {
                        enum_value.description()
                    },
                    variant_name,
                    discriminant
                ));
            }

            output.push_str("}\n\n");

            // Generate conversion implementations
            output.push_str(&format!(
                r#"impl {} {{
    /// Gets the FIX field value string.
    pub fn as_str(&self) -> &'static str {{
        match self {{
{}        }}
    }}
}}

impl ToFixFieldValue for {} {{
    fn to_fix_field_value(&self) -> crate::types::FixFieldValue {{
        crate::types::FixFieldValue::String(self.as_str().to_string())
    }}
}}

"#,
                enum_name,
                enums_vec
                    .iter()
                    .map(|enum_value| {
                        let mut variant_name = if enum_value.description().is_empty() {
                            enum_value.value()
                        } else {
                            enum_value.description()
                        }
                        .to_pascal_case();

                        // Handle identifiers that start with numbers
                        if variant_name
                            .chars()
                            .next()
                            .is_some_and(|c| c.is_ascii_digit())
                        {
                            variant_name = format!("V{variant_name}");
                        }

                        // Handle invalid characters
                        variant_name =
                            variant_name.replace(['/', ':', '-', ' ', '(', ')', '.'], "_");
                        format!(
                            "            Self::{} => \"{}\",\n",
                            variant_name,
                            enum_value.value()
                        )
                    })
                    .collect::<String>(),
                enum_name
            ));
        }
    }

    Ok(output)
}

/// Generates ASN.1 schemas from custom schema files in the schemas/ directory.
fn generate_custom_asn1_schemas() -> Result<()> {
    let schemas_dir = PathBuf::from(env!("CARGO_MANIFEST_DIR")).join("schemas");

    if !schemas_dir.exists() {
        // Create schemas directory with a sample schema
        fs::create_dir_all(&schemas_dir).context("Failed to create schemas directory")?;

        let sample_schema = r#"-- Sample ASN.1 schema for FIX message extensions
-- Place custom ASN.1 schemas in this directory for automatic compilation

FixExtensions DEFINITIONS ::= BEGIN

-- Custom message types
CustomMessageType ::= ENUMERATED {
    customHeartbeat(0),
    customLogon(1),
    customLogout(2)
}

-- Custom field definitions  
CustomField ::= SEQUENCE {
    tag     INTEGER (1..9999),
    value   UTF8String
}

-- Extended message structure
ExtendedFixMessage ::= SEQUENCE {
    msgType         CustomMessageType,
    senderCompId    UTF8String,
    targetCompId    UTF8String,
    msgSeqNum       INTEGER (1..999999999),
    customFields    SEQUENCE OF CustomField OPTIONAL
}

END
"#;

        fs::write(schemas_dir.join("sample.asn1"), sample_schema)
            .context("Failed to write sample ASN.1 schema")?;

        println!("cargo:warning=Created schemas/ directory with sample ASN.1 schema");
        println!(
            "cargo:warning=Place your custom ASN.1 schemas in schemas/ for automatic compilation"
        );
    }

    // Process any .asn1 files in the schemas directory using proper ASN.1 compilation
    compile_asn1_schemas(&schemas_dir).context("Failed to compile ASN.1 schemas")?;

    Ok(())
}

/// Compiles ASN.1 schema files using rasn-compiler for proper code generation.
fn compile_asn1_schemas(schemas_dir: &Path) -> Result<()> {
    let schema_pattern = schemas_dir.join("*.asn1");

    // Check if glob crate is available in build dependencies
    match glob::glob(&schema_pattern.to_string_lossy()) {
        Ok(entries) => {
            let out_dir =
                env::var("OUT_DIR").context("Failed to get OUT_DIR environment variable")?;
            let out_path = Path::new(&out_dir);

            for entry in entries {
                let schema_file = entry.context("Failed to read schema file entry")?;

                println!(
                    "cargo:warning=Compiling ASN.1 schema: {}",
                    schema_file.display()
                );

                // Get the filename without extension for generated Rust module
                let file_stem = schema_file
                    .file_stem()
                    .and_then(|s| s.to_str())
                    .with_context(|| format!("Invalid filename: {}", schema_file.display()))?;

                let output_file = format!("{file_stem}_asn1.rs");
                let output_path = out_path.join(&output_file);

                // Attempt to compile the ASN.1 schema
                match compile_asn1_file(&schema_file, &output_path) {
                    Ok(_) => {
                        println!(
                            "cargo:warning=Successfully compiled {} to {}",
                            schema_file.display(),
                            output_file
                        );
                    }
                    Err(e) => {
                        // If compilation fails, fall back to copying the file and warn
                        println!(
                            "cargo:warning=ASN.1 compilation failed for {}: {}. Copying file instead.",
                            schema_file.display(),
                            e
                        );
                        let filename = schema_file.file_name().with_context(|| {
                            format!(
                                "Schema file should have a valid filename: {}",
                                schema_file.display()
                            )
                        })?;
                        let fallback_path = out_path.join(filename);
                        fs::copy(&schema_file, fallback_path).with_context(|| {
                            format!("Failed to copy schema file {}", schema_file.display())
                        })?;
                    }
                }
            }
        }
        Err(e) => {
            println!("cargo:warning=Failed to search for ASN.1 schema files: {e}");
        }
    }

    Ok(())
}

/// Compiles a single ASN.1 schema file to Rust code.
/// This is a placeholder implementation - in practice you'd use rasn-compiler or similar.
fn compile_asn1_file(schema_file: &Path, output_path: &Path) -> Result<()> {
    // Read the ASN.1 schema file
    let schema_content = fs::read_to_string(schema_file)
        .with_context(|| format!("Failed to read schema file: {}", schema_file.display()))?;

    // For now, generate a simple Rust wrapper around the schema
    // In a full implementation, you would use rasn-compiler or implement proper ASN.1 parsing
    let rust_code = format!(
        r#"//! Generated Rust code from ASN.1 schema: {}
//! This file is automatically generated by the build script.
//! DO NOT EDIT MANUALLY - ALL CHANGES WILL BE OVERWRITTEN.
//! Generated on: {}

use rasn::{{AsnType, Decode, Encode}};

// TODO: Implement proper ASN.1 compilation
// For now, this is a placeholder that includes the original schema as documentation

/*
Original ASN.1 Schema:
{}
*/

/// Placeholder struct for compiled ASN.1 schema
#[derive(AsnType, Debug, Clone, PartialEq, Encode, Decode)]
#[rasn(crate_root = "rasn")]
pub struct CompiledSchema {{
    /// Placeholder field - replace with actual compiled types
    pub placeholder: String,
}}

impl Default for CompiledSchema {{
    fn default() -> Self {{
        Self {{
            placeholder: "Generated from {}".to_string(),
        }}
    }}
}}
"#,
        schema_file.display(),
        chrono::Utc::now().format("%Y-%m-%d %H:%M:%S UTC"),
        schema_content,
        schema_file
            .file_name()
            .unwrap_or_default()
            .to_string_lossy()
    );

    // Write the generated Rust code
    fs::write(output_path, rust_code).with_context(|| {
        format!(
            "Failed to write compiled schema to: {}",
            output_path.display()
        )
    })?;

    Ok(())
}
