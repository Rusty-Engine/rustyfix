//! Build script for ASN.1 schema compilation and code generation.

use anyhow::Result;
use heck::ToPascalCase;
use rustyfix_dictionary::Dictionary;
use std::collections::{BTreeMap, HashSet};
use std::env;
use std::fs;
use std::path::{Path, PathBuf};

/// Sanitizes a string to be a valid Rust identifier by replacing invalid characters.
/// For message types, preserves alphanumeric characters and replaces others with underscores.
/// Does not add prefix for numeric message types since they'll be used after an underscore.
fn sanitize_identifier(input: &str) -> String {
    let mut result = String::new();

    for ch in input.chars() {
        if ch.is_ascii_alphanumeric() {
            result.push(ch);
        } else {
            // Replace invalid characters (like /, +, -, etc.) with underscore
            result.push('_');
        }
    }

    // Ensure result is not empty
    if result.is_empty() {
        result = "_".to_string();
    }

    result
}

fn main() -> Result<()> {
    // Set up rerun conditions
    println!("cargo:rerun-if-changed=build.rs");
    println!("cargo:rerun-if-changed=schemas/");

    // Generate ASN.1 definitions from FIX dictionaries
    generate_fix_asn1_definitions()?;

    // Generate additional ASN.1 schema files if they exist
    generate_custom_asn1_schemas()?;

    Ok(())
}

/// Generates ASN.1 type definitions from FIX dictionaries.
fn generate_fix_asn1_definitions() -> Result<()> {
    let out_dir = env::var("OUT_DIR")?;
    let out_path = Path::new(&out_dir);

    // Generate for FIX 4.4 (primary version)
    let fix44_dict = Dictionary::fix44()?;
    generate_fix_dictionary_asn1(&fix44_dict, "fix44_asn1.rs", out_path)?;

    // Generate for other FIX versions if features are enabled
    // Build scripts don't inherit features, so we check environment variables instead
    if env::var("CARGO_FEATURE_FIX40").is_ok() {
        println!("cargo:warning=Generating ASN.1 definitions for FIX 4.0");
        let fix40_dict = Dictionary::fix40().expect("Failed to parse FIX 4.0 dictionary");
        generate_fix_dictionary_asn1(&fix40_dict, "fix40_asn1.rs", out_path)?;
    }

    if env::var("CARGO_FEATURE_FIX50").is_ok() {
        println!("cargo:warning=Generating ASN.1 definitions for FIX 5.0");
        let fix50_dict = Dictionary::fix50().expect("Failed to parse FIX 5.0 dictionary");
        generate_fix_dictionary_asn1(&fix50_dict, "fix50_asn1.rs", out_path)?;
    }

    Ok(())
}

/// Generates ASN.1 definitions for a specific FIX dictionary.
fn generate_fix_dictionary_asn1(
    dictionary: &Dictionary,
    filename: &str,
    out_path: &Path,
) -> Result<()> {
    let mut output = String::new();

    // File header
    output.push_str(&format!(
        r#"// Generated ASN.1 definitions for FIX {}.
// This file is automatically generated by the build script.
// DO NOT EDIT MANUALLY - ALL CHANGES WILL BE OVERWRITTEN.
// Generated on: {}

use rasn::{{AsnType, Decode, Encode}};
use crate::types::{{Field, ToFixFieldValue}};

"#,
        dictionary.version(),
        chrono::Utc::now().format("%Y-%m-%d %H:%M:%S UTC")
    ));

    // Generate message type enums
    output.push_str(&generate_message_type_enum(dictionary)?);
    output.push_str("\n\n");

    // Generate field tag enums
    output.push_str(&generate_field_tag_enum(dictionary)?);
    output.push_str("\n\n");

    // Generate message structures
    output.push_str(&generate_message_structures(dictionary)?);
    output.push_str("\n\n");

    // Generate field value enums
    output.push_str(&generate_field_value_enums(dictionary)?);

    // Write to output file
    let file_path = out_path.join(filename);
    fs::write(file_path, output)?;

    Ok(())
}

/// Generates ASN.1 enum for FIX message types.
fn generate_message_type_enum(dictionary: &Dictionary) -> Result<String> {
    let mut output = String::new();

    output.push_str(
        r#"/// ASN.1 enumeration of FIX message types.
#[derive(AsnType, Debug, Clone, Copy, PartialEq, Eq, Hash, Encode, Decode)]
#[rasn(crate_root = "rasn")]
#[rasn(enumerated)]
pub enum FixMessageType {
"#,
    );

    // Collect all message types
    let mut message_types: BTreeMap<String, String> = BTreeMap::new();
    let mut used_names = HashSet::new();

    for message in dictionary.messages() {
        let msg_type = message.msg_type();
        let name = message.name();
        let sanitized_msg_type = sanitize_identifier(msg_type);
        // For clean alphanumeric message types, concatenate without underscore for better Rust naming
        let mut enum_name = if sanitized_msg_type
            .chars()
            .all(|c| c.is_ascii_alphanumeric())
        {
            format!("{}{}", name.to_pascal_case(), sanitized_msg_type)
        } else {
            // Use underscore for complex sanitized types (those with replaced characters)
            format!("{}_{}", name.to_pascal_case(), sanitized_msg_type)
        };

        // Handle name collisions
        let mut counter = 1;
        while used_names.contains(&enum_name) {
            if sanitized_msg_type
                .chars()
                .all(|c| c.is_ascii_alphanumeric())
            {
                enum_name = format!("{}{}{}", name.to_pascal_case(), sanitized_msg_type, counter);
            } else {
                enum_name = format!(
                    "{}_{}{}",
                    name.to_pascal_case(),
                    sanitized_msg_type,
                    counter
                );
            }
            counter += 1;
        }
        used_names.insert(enum_name.clone());

        message_types.insert(msg_type.to_string(), enum_name);
    }

    // Generate enum variants
    for (discriminant, (msg_type, enum_name)) in message_types.iter().enumerate() {
        output.push_str(&format!(
            "    /// Message type '{msg_type}'\n    {enum_name} = {discriminant},\n"
        ));
    }

    output.push_str("}\n\n");

    // Generate conversion implementations
    output.push_str(&format!(
        r#"impl FixMessageType {{
    /// Gets the FIX message type string.
    pub fn as_str(&self) -> &'static str {{
        match self {{
{}        }}
    }}
    
    /// Creates from FIX message type string.
    pub fn from_str(s: &str) -> Option<Self> {{
        match s {{
{}            _ => None,
        }}
    }}
}}

impl ToFixFieldValue for FixMessageType {{
    fn to_fix_field_value(&self) -> crate::types::FixFieldValue {{
        crate::types::FixFieldValue::String(self.as_str().to_string())
    }}
}}
"#,
        message_types
            .iter()
            .map(|(msg_type, enum_name)| format!(
                "            Self::{enum_name} => \"{msg_type}\",\n"
            ))
            .collect::<String>(),
        message_types
            .iter()
            .map(|(msg_type, enum_name)| format!(
                "            \"{msg_type}\" => Some(Self::{enum_name}),\n"
            ))
            .collect::<String>()
    ));

    Ok(output)
}

/// Generates ASN.1 enum for FIX field tags.
fn generate_field_tag_enum(dictionary: &Dictionary) -> Result<String> {
    let mut output = String::new();

    output.push_str(
        r#"/// ASN.1 enumeration of FIX field tags.
#[derive(AsnType, Debug, Clone, Copy, PartialEq, Eq, Hash, Encode, Decode)]
#[rasn(crate_root = "rasn")]
#[rasn(enumerated)]
pub enum FixFieldTag {
"#,
    );

    // Collect all field tags
    let mut field_tags: BTreeMap<u32, String> = BTreeMap::new();

    for field in dictionary.fields() {
        let tag = field.tag();
        let name = field.name().to_pascal_case();
        field_tags.insert(tag.get(), name);
    }

    // Generate enum variants
    for (tag, name) in &field_tags {
        output.push_str(&format!(
            "    /// Field tag {tag} ({name})\n    {name} = {tag},\n"
        ));
    }

    output.push_str("}\n\n");

    // Generate conversion implementations
    output.push_str(&format!(
        r#"impl FixFieldTag {{
    /// Gets the field tag number.
    pub fn as_u32(&self) -> u32 {{
        *self as u32
    }}
    
    /// Creates from field tag number.
    pub fn from_u32(tag: u32) -> Option<Self> {{
        match tag {{
{}            _ => None,
        }}
    }}
}}

impl From<FixFieldTag> for u32 {{
    fn from(tag: FixFieldTag) -> Self {{
        tag.as_u32()
    }}
}}

impl ToFixFieldValue for FixFieldTag {{
    fn to_fix_field_value(&self) -> crate::types::FixFieldValue {{
        crate::types::FixFieldValue::UnsignedInteger(self.as_u32() as u64)
    }}
}}
"#,
        field_tags
            .iter()
            .map(|(tag, name)| format!("            {tag} => Some(Self::{name}),\n"))
            .collect::<String>()
    ));

    Ok(output)
}

/// Generates ASN.1 message structures for different FIX message types.
fn generate_message_structures(_dictionary: &Dictionary) -> Result<String> {
    let mut output = String::new();

    // Generate a generic ASN.1 message container
    output.push_str(
        r#"/// Generic ASN.1 FIX message structure.
#[derive(AsnType, Debug, Clone, PartialEq, Encode, Decode)]
#[rasn(crate_root = "rasn")]
pub struct Asn1FixMessage {
    /// Message type
    #[rasn(tag(0))]
    pub msg_type: FixMessageType,
    
    /// Sender company ID
    #[rasn(tag(1))]
    pub sender_comp_id: String,
    
    /// Target company ID  
    #[rasn(tag(2))]
    pub target_comp_id: String,
    
    /// Message sequence number
    #[rasn(tag(3))]
    pub msg_seq_num: u64,
    
    /// Sending time (optional)
    #[rasn(tag(4))]
    pub sending_time: Option<String>,
    
    /// Message fields
    #[rasn(tag(5))]
    pub fields: Vec<Asn1Field>,
}

/// ASN.1 representation of a FIX field.
#[derive(AsnType, Debug, Clone, PartialEq, Encode, Decode)]
#[rasn(crate_root = "rasn")]
pub struct Asn1Field {
    /// Field tag
    #[rasn(tag(0))]
    pub tag: FixFieldTag,
    
    /// Field value as string
    #[rasn(tag(1))]
    pub value: String,
}

"#,
    );

    // Generate conversion methods
    output.push_str(
        r#"impl Asn1FixMessage {
    /// Converts from the simple FixMessage representation.
    pub fn from_fix_message(msg: &crate::types::FixMessage) -> Option<Self> {
        let msg_type = FixMessageType::from_str(&msg.msg_type)?;
        
        let fields = msg.fields
            .iter()
            .filter_map(|field| {
                let tag = FixFieldTag::from_u32(field.tag as u32)?;
                Some(Asn1Field {
                    tag,
                    value: field.value.to_string(),
                })
            })
            .collect();
        
        Some(Self {
            msg_type,
            sender_comp_id: msg.sender_comp_id.clone(),
            target_comp_id: msg.target_comp_id.clone(),
            msg_seq_num: msg.msg_seq_num,
            sending_time: None, // TODO: Extract from fields if present
            fields,
        })
    }
    
    /// Converts to the simple FixMessage representation.
    pub fn to_fix_message(&self) -> crate::types::FixMessage {
        let fields = self.fields
            .iter()
            .map(|field| Field {
                tag: field.tag.as_u32(),
                value: crate::types::FixFieldValue::String(field.value.clone()),
            })
            .collect();
        
        crate::types::FixMessage {
            msg_type: self.msg_type.as_str().to_string(),
            sender_comp_id: self.sender_comp_id.clone(),
            target_comp_id: self.target_comp_id.clone(),
            msg_seq_num: self.msg_seq_num,
            fields,
        }
    }
}

"#,
    );

    Ok(output)
}

/// Generates ASN.1 enums for FIX field values that have restricted sets.
fn generate_field_value_enums(dictionary: &Dictionary) -> Result<String> {
    let mut output = String::new();

    output.push_str("// Field value enumerations\n\n");

    for field in dictionary.fields() {
        if let Some(enums) = field.enums() {
            let enums_vec: Vec<_> = enums.collect();
            let field_name = field.name().to_pascal_case();
            let enum_name = format!("{field_name}Value");

            output.push_str(&format!(
                r#"/// Allowed values for field {} (tag {}).
#[derive(AsnType, Debug, Clone, Copy, PartialEq, Eq, Hash, Encode, Decode)]
#[rasn(crate_root = "rasn")]
#[rasn(enumerated)]
pub enum {} {{
"#,
                field.name(),
                field.tag(),
                enum_name
            ));

            // Generate enum variants
            for (discriminant, enum_value) in enums_vec.iter().enumerate() {
                let mut variant_name = if enum_value.description().is_empty() {
                    enum_value.value()
                } else {
                    enum_value.description()
                }
                .to_pascal_case();

                // Handle identifiers that start with numbers
                if variant_name
                    .chars()
                    .next()
                    .is_some_and(|c| c.is_ascii_digit())
                {
                    variant_name = format!("V{variant_name}");
                }

                // Handle invalid characters
                variant_name = variant_name.replace(['/', ':', '-', ' ', '(', ')', '.'], "_");

                output.push_str(&format!(
                    "    /// {}\n    {} = {},\n",
                    if enum_value.description().is_empty() {
                        ""
                    } else {
                        enum_value.description()
                    },
                    variant_name,
                    discriminant
                ));
            }

            output.push_str("}\n\n");

            // Generate conversion implementations
            output.push_str(&format!(
                r#"impl {} {{
    /// Gets the FIX field value string.
    pub fn as_str(&self) -> &'static str {{
        match self {{
{}        }}
    }}
}}

impl ToFixFieldValue for {} {{
    fn to_fix_field_value(&self) -> crate::types::FixFieldValue {{
        crate::types::FixFieldValue::String(self.as_str().to_string())
    }}
}}

"#,
                enum_name,
                enums_vec
                    .iter()
                    .map(|enum_value| {
                        let mut variant_name = if enum_value.description().is_empty() {
                            enum_value.value()
                        } else {
                            enum_value.description()
                        }
                        .to_pascal_case();

                        // Handle identifiers that start with numbers
                        if variant_name
                            .chars()
                            .next()
                            .is_some_and(|c| c.is_ascii_digit())
                        {
                            variant_name = format!("V{variant_name}");
                        }

                        // Handle invalid characters
                        variant_name =
                            variant_name.replace(['/', ':', '-', ' ', '(', ')', '.'], "_");
                        format!(
                            "            Self::{} => \"{}\",\n",
                            variant_name,
                            enum_value.value()
                        )
                    })
                    .collect::<String>(),
                enum_name
            ));
        }
    }

    Ok(output)
}

/// Generates ASN.1 schemas from custom schema files in the schemas/ directory.
fn generate_custom_asn1_schemas() -> Result<()> {
    let schemas_dir = PathBuf::from(env!("CARGO_MANIFEST_DIR")).join("schemas");

    if !schemas_dir.exists() {
        // Create schemas directory with a sample schema
        fs::create_dir_all(&schemas_dir)?;

        let sample_schema = r#"-- Sample ASN.1 schema for FIX message extensions
-- Place custom ASN.1 schemas in this directory for automatic compilation

FixExtensions DEFINITIONS ::= BEGIN

-- Custom message types
CustomMessageType ::= ENUMERATED {
    customHeartbeat(0),
    customLogon(1),
    customLogout(2)
}

-- Custom field definitions  
CustomField ::= SEQUENCE {
    tag     INTEGER (1..9999),
    value   UTF8String
}

-- Extended message structure
ExtendedFixMessage ::= SEQUENCE {
    msgType         CustomMessageType,
    senderCompId    UTF8String,
    targetCompId    UTF8String,
    msgSeqNum       INTEGER (1..999999999),
    customFields    SEQUENCE OF CustomField OPTIONAL
}

END
"#;

        fs::write(schemas_dir.join("sample.asn1"), sample_schema)?;

        println!("cargo:warning=Created schemas/ directory with sample ASN.1 schema");
        println!(
            "cargo:warning=Place your custom ASN.1 schemas in schemas/ for automatic compilation"
        );
    }

    // Process any .asn1 files in the schemas directory
    let schema_pattern = schemas_dir.join("*.asn1");
    if let Ok(entries) = glob::glob(&schema_pattern.to_string_lossy()) {
        for entry in entries {
            let schema_file = entry?;
            println!(
                "cargo:warning=Found ASN.1 schema: {}",
                schema_file.display()
            );

            // For now, just copy the schema files to OUT_DIR
            // In a full implementation, you would parse and compile them
            let out_dir = env::var("OUT_DIR")?;
            let filename = schema_file
                .file_name()
                .expect("Schema file should have a valid filename");
            let output_path = Path::new(&out_dir).join(filename);
            fs::copy(&schema_file, output_path)?;
        }
    }

    Ok(())
}
